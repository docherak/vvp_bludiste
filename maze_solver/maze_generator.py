"""
Module to generate mazes of different types.
"""

from .maze_solver import Maze
import numpy as np
from enum import Enum

# Enum class to represent different types of mazes
MazeType = Enum("MazeType", "EMPTY LINE SLALOM ANGRY_BIRDS RANDOM")


class MazeGenerator(Maze):
    """
    Class for generating mazes of different types.

    Inherits from the Maze class and adds methods to generate mazes of different types.

    Attributes:
        type (MazeType): Type of the maze.

    Methods:
        lines: Generates a maze with horizontal lines.
        slalom: Generates a maze with a slalom pattern.
        angry_birds: Generates a maze with columns of obstacles.
        randomize: Randomizes the maze with a given probability.
    """

    def __init__(self, n: int) -> None:
        """
        Initializes the maze generator with an empty maze of size n x n.

        Args:
            n (int): Size of the maze.
        """
        super().__init__(np.zeros((n, n), dtype=bool))
        self.type = MazeType.EMPTY

    def lines(self) -> None:
        """
        Generates a solvable maze with horizontal lines.

        The maze is generated by setting every other row to be a wall and creating a random opening in each row.
        """
        self.type = MazeType.LINE
        r, c = self.map.shape
        line_spacing = np.random.randint(
            2, r // 3
        )  # Determine the spacing between lines
        for i in range(1, r - 1, line_spacing):
            for j in range(c):
                if not self.map[i, j]:
                    self.map[i, j] = True  # Set every other row to be a wall
            rand = np.random.randint(0, c)
            self.map[i, rand] = False  # Create a random opening in each row

        self.map[0, 0] = False  # Ensure the start point is open
        self.map[-1, -1] = False  # Ensure the end point is open

    def slalom(self) -> None:
        """
        Generates a solvable maze with a slalom pattern.

        The maze is generated by setting two walls that zigzag across the maze.
        """
        self.type = MazeType.SLALOM
        r, c = self.map.shape
        self.map[:, :] = False  # Clear the maze
        w = c // 10  # Determine the width of the slalom walls
        i = c // 4  # Determine the initial position of the slalom

        # Create the zigzag pattern
        self.map[i - w : i + w, 0:-i] = True
        self.map[-i - w : -i + w, i:] = True

        self.map[0, 0] = False  # Ensure the start point is open
        self.map[-1, -1] = False  # Ensure the end point is open

    def angry_birds(self, num_columns: int) -> None:
        """
        Generates a solvable maze with columns of obstacles resembling the Angry Birds game.

        The maze is generated by setting columns of obstacles with a random width and spacing.

        The input parameter num_columns specifies the number of columns of obstacles to generate and is adjusted if it exceeds the maximum number of columns that can fit within the maze dimensions.

        Args:
            num_columns (int): Number of columns of obstacles to generate.
        """
        self.type = MazeType.ANGRY_BIRDS
        r, c = self.map.shape
        self.map[:, :] = False  # Clear the maze

        # Maximum number of columns that can fit within the maze dimensions
        max_columns = (c - 1) // 4
        if num_columns > max_columns:
            num_columns = max_columns
            print(f"Number of columns adjusted to fit the maze: {num_columns}")

        spacing = c // (num_columns + 1)
        w = max(1, spacing // 4)  # Determine the width of the columns

        for k in range(1, num_columns + 1):
            col = k * spacing
            if col - w < 0 or col + w >= c:
                continue  # Skip columns that would exceed the maze bounds
            # Create the column of obstacles
            if k % 2 == 1:
                self.map[0 : r - 2, col - w : col + w] = True
            else:
                self.map[2:r, col - w : col + w] = True

        self.map[0, 0] = False  # Ensure the start point is open
        self.map[-1, -1] = False  # Ensure the end point is open

    def randomize(self, p: float = 0.05) -> None:
        """
        Randomizes the maze with a given probability.

        The maze is randomized by setting each cell to be a wall with probability p and an opening with probability 1 - p. This controls the density of the maze.

        Args:
            p (float): Probability of setting a cell to be a wall.
        """
        # If the maze is empty, generate a random maze with a valid path
        if self.type == MazeType.EMPTY:
            while True:
                temp_map = np.random.choice(
                    [True, False], size=self.map.shape, p=[p, 1 - p]
                )
                temp_map[self.map] = True
                temp_map[0, 0] = False
                temp_map[-1, -1] = False
                self.map = temp_map

                # Ensure the maze has a valid path from start to end
                path = self.dijkstra(self.incidence_matrix())
                if len(path) > 0:
                    break

            for i in path:
                r, c = divmod(i, self.map.shape[1])
                self.map[r, c] = False  # Clear the path cells
        # If the maze is not empty, randomize the existing maze
        else:
            temp_map = np.random.choice(
                [True, False], size=self.map.shape, p=[p, 1 - p]
            )
            temp_map[self.map] = True
            temp_map[0, 0] = False
            temp_map[-1, -1] = False
            self.map = temp_map

        self.type = MazeType.RANDOM
